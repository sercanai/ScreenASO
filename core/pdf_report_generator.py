"""
PDF Report Generator for Screen ASO analysis.
Creates professional PDF reports with charts and insights.
"""

import json
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Any, Optional
import io

import matplotlib
matplotlib.use('Agg')  # Non-interactive backend
import matplotlib.pyplot as plt
import seaborn as sns
from wordcloud import WordCloud
import numpy as np
import pandas as pd
from reportlab.lib import colors
from reportlab.lib.pagesizes import A4, letter
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
from reportlab.platypus import (
    SimpleDocTemplate, Paragraph, Spacer, Image, PageBreak,
    Table, TableStyle, KeepTogether
)
from reportlab.lib.enums import TA_CENTER, TA_LEFT, TA_RIGHT
from reportlab.pdfgen import canvas


# Set style
sns.set_style("whitegrid")
plt.rcParams['figure.dpi'] = 150
plt.rcParams['savefig.dpi'] = 150
plt.rcParams['font.size'] = 10


class PDFReportGenerator:
    """Generate professional PDF reports from Screen ASO analysis data."""
    
    def __init__(self, language: str = "en", page_size=A4):
        """Initialize PDF generator."""
        self.language = language
        self.page_size = page_size
        self.width, self.height = page_size
        self.styles = getSampleStyleSheet()
        self._setup_styles()
        
        # Track temporary files for cleanup
        self.temp_files = []
    
    def __del__(self):
        """Cleanup temporary files on deletion."""
        self._cleanup_temp_files()
    
    def _cleanup_temp_files(self):
        """Delete all temporary image files."""
        for temp_file in self.temp_files:
            try:
                if temp_file.exists():
                    temp_file.unlink()
            except Exception:
                pass
        self.temp_files.clear()
    
    # Translations
    TRANSLATIONS = {
        "en": {
            "title": "Screen ASO Analysis Report",
            "executive_summary": "Executive Summary",
            "app_info": "Application Information",
            "key_metrics": "Key Metrics",
            "sentiment_analysis": "Sentiment Analysis",
            "aspect_sentiment": "Aspect Sentiment Analysis",
            "review_analysis": "Review Analysis",
            "keyword_insights": "Keyword Insights",
            "actionable_insights": "Actionable Insights",
            "total_reviews": "Total Reviews Analyzed",
            "sentiment_breakdown": "Sentiment Breakdown",
            "positive": "Positive",
            "negative": "Negative",
            "neutral": "Neutral",
            "avg_sentiment": "Average Sentiment Score",
            "needs_reply": "Needs Reply",
            "top_issues": "Top Issues",
            "top_praises": "Top Praises",
            "rating": "Rating",
            "developer": "Developer",
            "store": "Store",
            "country": "Country",
            "language": "Language",
            "analysis_date": "Analysis Date",
            "review_types": "Review Type Distribution",
            "description_keywords": "Description Keywords",
            "review_keywords": "Review Keywords",
            "common_keywords": "Common Keywords",
            "urgent_actions": "Urgent Actions",
            "feature_requests": "Feature Requests",
            "user_personas": "User Personas",
            "generated_by": "Generated by Screen ASO Analyzer",
            "table_of_contents": "Table of Contents",
            "quick_wins": "Quick Wins",
            "rating_breakdown": "Rating Breakdown",
            "aspect_radar": "Aspect Performance Radar",
            "review_examples": "Review Examples",
            "best_reviews": "Top Positive Reviews",
            "worst_reviews": "Critical Reviews",
            "page": "Page",
            "of": "of",
        },
        "tr": {
            "title": "Screen ASO Analiz Raporu",
            "executive_summary": "YÃ¶netici Ã–zeti",
            "app_info": "Uygulama Bilgileri",
            "key_metrics": "Temel Metrikler",
            "sentiment_analysis": "Duygu Analizi",
            "aspect_sentiment": "YÃ¶nlÃ¼ Duygu Analizi",
            "review_analysis": "Yorum Analizi",
            "keyword_insights": "Anahtar Kelime Ä°Ã§gÃ¶rÃ¼leri",
            "actionable_insights": "Eylem Ã–nerileri",
            "total_reviews": "Analiz Edilen Toplam Yorum",
            "sentiment_breakdown": "Duygu DaÄŸÄ±lÄ±mÄ±",
            "positive": "Olumlu",
            "negative": "Olumsuz",
            "neutral": "NÃ¶tr",
            "avg_sentiment": "Ortalama Duygu Skoru",
            "needs_reply": "YanÄ±t Gerekiyor",
            "top_issues": "En Ã–nemli Sorunlar",
            "top_praises": "En Ã‡ok Ã–vÃ¼lenler",
            "rating": "Puan",
            "developer": "GeliÅŸtirici",
            "store": "MaÄŸaza",
            "country": "Ãœlke",
            "language": "Dil",
            "analysis_date": "Analiz Tarihi",
            "review_types": "Yorum Tipi DaÄŸÄ±lÄ±mÄ±",
            "description_keywords": "AÃ§Ä±klama Anahtar Kelimeleri",
            "review_keywords": "Yorum Anahtar Kelimeleri",
            "common_keywords": "Ortak Anahtar Kelimeler",
            "urgent_actions": "Acil Eylemler",
            "feature_requests": "Ã–zellik Ä°stekleri",
            "user_personas": "KullanÄ±cÄ± Profilleri",
            "generated_by": "Screen ASO Analyzer tarafÄ±ndan oluÅŸturuldu",
            "table_of_contents": "Ä°Ã§indekiler",
            "quick_wins": "HÄ±zlÄ± KazanÃ§lar",
            "rating_breakdown": "Puan DaÄŸÄ±lÄ±mÄ±",
            "aspect_radar": "YÃ¶n Performans RadarÄ±",
            "review_examples": "Yorum Ã–rnekleri",
            "best_reviews": "En Ä°yi Yorumlar",
            "worst_reviews": "Kritik Yorumlar",
            "page": "Sayfa",
            "of": "/",
        }
    }
    
    def _setup_styles(self):
        """Setup custom paragraph styles."""
        # Title style
        self.styles.add(ParagraphStyle(
            name='CustomTitle',
            parent=self.styles['Heading1'],
            fontSize=24,
            textColor=colors.HexColor('#1a1a1a'),
            spaceAfter=30,
            alignment=TA_CENTER,
            fontName='Helvetica-Bold'
        ))
        
        # Section header
        self.styles.add(ParagraphStyle(
            name='SectionHeader',
            parent=self.styles['Heading2'],
            fontSize=16,
            textColor=colors.HexColor('#2c3e50'),
            spaceAfter=12,
            spaceBefore=12,
            fontName='Helvetica-Bold'
        ))
        
        # Subsection
        self.styles.add(ParagraphStyle(
            name='SubSection',
            parent=self.styles['Heading3'],
            fontSize=12,
            textColor=colors.HexColor('#34495e'),
            spaceAfter=6,
            fontName='Helvetica-Bold'
        ))
    
    def t(self, key: str) -> str:
        """Translate key to current language."""
        return self.TRANSLATIONS[self.language].get(key, key)
    
    def generate_report(
        self,
        summary: Dict[str, Any],
        sentiment_data: Dict[str, Any],
        keyword_data: Dict[str, Any],
        output_path: Path,
        charts: Optional[List[str]] = None
    ):
        """Generate complete PDF report."""
        
        # Create PDF document with page numbers
        doc = SimpleDocTemplate(
            str(output_path),
            pagesize=self.page_size,
            rightMargin=0.75*inch,
            leftMargin=0.75*inch,
            topMargin=0.75*inch,
            bottomMargin=0.75*inch
        )
        
        # Build content
        story = []
        
        # Cover page
        story.extend(self._create_cover_page(summary, sentiment_data))
        story.append(PageBreak())
        
        # Table of Contents
        story.extend(self._create_table_of_contents())
        story.append(PageBreak())
        
        # Executive summary with color-coded boxes
        story.extend(self._create_executive_summary(summary, sentiment_data))
        story.append(PageBreak())
        
        # Rating breakdown
        story.extend(self._create_rating_breakdown_section(sentiment_data))
        story.append(PageBreak())
        
        # Sentiment analysis
        if not charts or 'sentiment' in charts:
            story.extend(self._create_sentiment_section(sentiment_data))
            story.append(PageBreak())
        
        # Aspect sentiment with radar chart
        if not charts or 'aspects' in charts:
            story.extend(self._create_aspect_section(sentiment_data))
            story.append(PageBreak())
        
        # Review analysis
        if not charts or 'reviews' in charts:
            story.extend(self._create_review_section(summary, sentiment_data))
            story.append(PageBreak())
        
        # Keyword insights
        if not charts or 'keywords' in charts:
            story.extend(self._create_keyword_section(keyword_data))
            story.append(PageBreak())
        
        # Quick Wins + Actionable insights
        story.extend(self._create_quick_wins_section(sentiment_data, keyword_data))
        story.append(PageBreak())
        story.extend(self._create_insights_section(sentiment_data, keyword_data))
        
        # Build PDF with page numbers
        doc.build(story, onFirstPage=self._add_page_number, onLaterPages=self._add_page_number)
        
        # Cleanup temporary files
        self._cleanup_temp_files()
    
    def _create_cover_page(self, summary: Dict, sentiment_data: Dict) -> List:
        """Create cover page with gradient-like effect."""
        elements = []
        
        # Title with colored background box
        elements.append(Spacer(1, 1.2*inch))
        
        # Create a colored title box
        title_table = Table(
            [[Paragraph(self.t("title"), 
                       ParagraphStyle('TitleBox', parent=self.styles['Normal'],
                                    fontSize=24, alignment=TA_CENTER, textColor=colors.white,
                                    fontName='Helvetica-Bold'))]],
            colWidths=[6*inch]
        )
        title_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, -1), colors.HexColor('#2c3e50')),
            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
            ('TOPPADDING', (0, 0), (-1, -1), 20),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 20),
            ('LEFTPADDING', (0, 0), (-1, -1), 20),
            ('RIGHTPADDING', (0, 0), (-1, -1), 20),
        ]))
        elements.append(title_table)
        elements.append(Spacer(1, 0.5*inch))
        
        # App name
        app_name = summary.get('app_name', 'Unknown App')
        elements.append(Paragraph(
            f"<b>{app_name}</b>",
            ParagraphStyle(
                'AppName',
                parent=self.styles['Normal'],
                fontSize=18,
                alignment=TA_CENTER,
                textColor=colors.HexColor('#2c3e50')
            )
        ))
        elements.append(Spacer(1, 0.3*inch))
        
        # Rating with stars
        rating = summary.get('rating', 0)
        rating_count = summary.get('rating_count', 0)
        stars = 'â­' * int(rating)
        elements.append(Paragraph(
            f"{stars} {rating:.2f} ({rating_count:,} {self.t('rating').lower()}s)",
            ParagraphStyle(
                'Rating',
                parent=self.styles['Normal'],
                fontSize=14,
                alignment=TA_CENTER
            )
        ))
        
        elements.append(Spacer(1, 0.8*inch))
        
        # Info table with alternating colors
        info_data = [
            [self.t("developer"), summary.get('developer', 'N/A')],
            [self.t("store"), sentiment_data.get('store', 'N/A').title()],
            [self.t("country"), sentiment_data.get('country', 'N/A').upper()],
            [self.t("language"), sentiment_data.get('language', 'N/A').upper()],
            [self.t("analysis_date"), datetime.now().strftime("%Y-%m-%d")],
        ]
        
        info_table = Table(info_data, colWidths=[2*inch, 3*inch])
        info_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#34495e')),
            ('BACKGROUND', (1, 0), (1, -1), colors.HexColor('#ecf0f1')),
            ('TEXTCOLOR', (0, 0), (0, -1), colors.white),
            ('TEXTCOLOR', (1, 0), (1, -1), colors.HexColor('#2c3e50')),
            ('ALIGN', (0, 0), (0, -1), 'RIGHT'),
            ('ALIGN', (1, 0), (1, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
            ('FONTNAME', (1, 0), (1, -1), 'Helvetica'),
            ('FONTSIZE', (0, 0), (-1, -1), 11),
            ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#bdc3c7')),
            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
            ('TOPPADDING', (0, 0), (-1, -1), 8),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
            ('LEFTPADDING', (0, 0), (-1, -1), 12),
            ('RIGHTPADDING', (0, 0), (-1, -1), 12),
        ]))
        
        elements.append(info_table)
        elements.append(Spacer(1, 1.5*inch))
        
        # Footer
        elements.append(Paragraph(
            self.t("generated_by"),
            ParagraphStyle(
                'Footer',
                parent=self.styles['Normal'],
                fontSize=9,
                alignment=TA_CENTER,
                textColor=colors.HexColor('#95a5a6')
            )
        ))
        
        return elements

    
    def _add_page_number(self, canvas_obj, doc):
        """Add page numbers to each page."""
        page_num = canvas_obj.getPageNumber()
        text = f"{self.t('page')} {page_num}"
        canvas_obj.saveState()
        canvas_obj.setFont('Helvetica', 9)
        canvas_obj.setFillColor(colors.HexColor('#95a5a6'))
        canvas_obj.drawRightString(self.width - 0.75*inch, 0.5*inch, text)
        canvas_obj.restoreState()
    
    def _create_table_of_contents(self) -> List:
        """Create table of contents."""
        elements = []
        
        elements.append(Paragraph(self.t("table_of_contents"), self.styles['SectionHeader']))
        elements.append(Spacer(1, 0.3*inch))
        
        toc_data = [
            ["1.", self.t("executive_summary"), "3"],
            ["2.", self.t("rating_breakdown"), "4"],
            ["3.", self.t("sentiment_analysis"), "5"],
            ["4.", self.t("aspect_sentiment"), "6"],
            ["5.", self.t("review_analysis"), "7"],
            ["6.", self.t("keyword_insights"), "8"],
            ["7.", self.t("quick_wins"), "9"],
            ["8.", self.t("actionable_insights"), "10"],
        ]
        
        toc_table = Table(toc_data, colWidths=[0.5*inch, 4.5*inch, 1*inch])
        toc_table.setStyle(TableStyle([
            ('ALIGN', (0, 0), (0, -1), 'RIGHT'),
            ('ALIGN', (1, 0), (1, -1), 'LEFT'),
            ('ALIGN', (2, 0), (2, -1), 'RIGHT'),
            ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),
            ('FONTSIZE', (0, 0), (-1, -1), 11),
            ('TOPPADDING', (0, 0), (-1, -1), 8),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
            ('LINEBELOW', (0, 0), (-1, -1), 0.5, colors.HexColor('#ecf0f1')),
        ]))
        
        elements.append(toc_table)
        
        return elements
    
    def _create_executive_summary(self, summary: Dict, sentiment_data: Dict) -> List:
        """Create executive summary page."""
        elements = []
        
        elements.append(Paragraph(self.t("executive_summary"), self.styles['SectionHeader']))
        elements.append(Spacer(1, 0.3*inch))
        
        # Color-coded sentiment boxes (only positive and negative)
        reviews_analyzed = summary.get('reviews_analyzed', 0)
        sentiment = summary.get('sentiment', {})
        
        pos_count = sentiment.get('positive', 0)
        neg_count = sentiment.get('negative', 0)
        
        pos_pct = (pos_count / max(reviews_analyzed, 1) * 100)
        neg_pct = (neg_count / max(reviews_analyzed, 1) * 100)
        
        # Create colored boxes (2 columns)
        sentiment_boxes = [
            [
                Paragraph(f"<b>{self.t('positive')}</b><br/>{pos_count}<br/>{pos_pct:.1f}%",
                         ParagraphStyle('PosBox', parent=self.styles['Normal'], 
                                      alignment=TA_CENTER, fontSize=14, textColor=colors.white)),
                Paragraph(f"<b>{self.t('negative')}</b><br/>{neg_count}<br/>{neg_pct:.1f}%",
                         ParagraphStyle('NegBox', parent=self.styles['Normal'],
                                      alignment=TA_CENTER, fontSize=14, textColor=colors.white)),
            ]
        ]
        
        sentiment_table = Table(sentiment_boxes, colWidths=[3*inch, 3*inch])
        sentiment_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (0, 0), colors.HexColor('#27ae60')),
            ('BACKGROUND', (1, 0), (1, 0), colors.HexColor('#e74c3c')),
            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
            ('TOPPADDING', (0, 0), (-1, -1), 20),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 20),
            ('GRID', (0, 0), (-1, -1), 3, colors.white),
        ]))
        
        elements.append(sentiment_table)
        elements.append(Spacer(1, 0.4*inch))
        
        # Key metrics
        elements.append(Paragraph(self.t("key_metrics"), self.styles['SubSection']))
        
        metrics_data = [
            [self.t("total_reviews"), str(reviews_analyzed)],
        ]
        
        metrics_table = Table(metrics_data, colWidths=[3*inch, 2*inch])
        metrics_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#ecf0f1')),
            ('TEXTCOLOR', (0, 0), (-1, -1), colors.HexColor('#2c3e50')),
            ('ALIGN', (0, 0), (0, -1), 'LEFT'),
            ('ALIGN', (1, 0), (1, -1), 'RIGHT'),
            ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
            ('FONTNAME', (1, 0), (1, -1), 'Helvetica'),
            ('FONTSIZE', (0, 0), (-1, -1), 10),
            ('GRID', (0, 0), (-1, -1), 0.5, colors.HexColor('#bdc3c7')),
            ('TOPPADDING', (0, 0), (-1, -1), 6),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
        ]))
        
        elements.append(metrics_table)
        elements.append(Spacer(1, 0.3*inch))
        
        # Top keywords from description
        elements.append(Paragraph(self.t("description_keywords"), self.styles['SubSection']))
        top_keywords_description = summary.get('top_keywords_description', [])[:10]
        if top_keywords_description:
            # Create two columns for better space usage
            desc_keywords_text = ", ".join(top_keywords_description)
            elements.append(Paragraph(desc_keywords_text, self.styles['Normal']))
        else:
            elements.append(Paragraph("No data available", self.styles['Normal']))
        
        elements.append(Spacer(1, 0.2*inch))
        
        # Top keywords from reviews
        elements.append(Paragraph(self.t("review_keywords"), self.styles['SubSection']))
        top_keywords_reviews = summary.get('top_keywords_reviews', [])[:10]
        if top_keywords_reviews:
            review_keywords_text = ", ".join(top_keywords_reviews)
            elements.append(Paragraph(review_keywords_text, self.styles['Normal']))
        else:
            elements.append(Paragraph("No data available", self.styles['Normal']))
        
        elements.append(Spacer(1, 0.2*inch))
        
        # Common keywords
        elements.append(Paragraph(self.t("common_keywords"), self.styles['SubSection']))
        common_keywords = summary.get('common_keywords', [])[:5]
        if common_keywords:
            common_keywords_text = ", ".join(common_keywords)
            elements.append(Paragraph(common_keywords_text, self.styles['Normal']))
        else:
            elements.append(Paragraph("No data available", self.styles['Normal']))
        
        return elements
    
    def _create_rating_breakdown_section(self, sentiment_data: Dict) -> List:
        """Create rating breakdown section with horizontal bar chart."""
        elements = []
        
        elements.append(Paragraph(self.t("rating_breakdown"), self.styles['SectionHeader']))
        elements.append(Spacer(1, 0.2*inch))
        
        # Create rating breakdown chart
        img_path = self._create_rating_breakdown_chart(sentiment_data)
        if img_path:
            img = Image(str(img_path), width=6*inch, height=4*inch)
            elements.append(img)
        else:
            elements.append(Paragraph("No rating data available", self.styles['Normal']))
        
        return elements
    
    
    def _create_quick_wins_section(self, sentiment_data: Dict, keyword_data: Dict) -> List:
        """Create quick wins section with actionable low-effort/high-impact items."""
        elements = []
        
        elements.append(Paragraph(self.t("quick_wins"), self.styles['SectionHeader']))
        elements.append(Spacer(1, 0.2*inch))
        
        elements.append(Paragraph(
            "Low effort, high impact actions you can take immediately:",
            self.styles['Normal']
        ))
        elements.append(Spacer(1, 0.15*inch))
        
        # Analyze reviews for quick wins
        reviews = sentiment_data.get('reviews', [])
        
        # Count issue types
        issue_counts = {}
        feature_counts = {}
        
        for review in reviews:
            if review.get('sentiment_label') == 'negative':
                review_type = review.get('review_type', '')
                if review_type == 'bug_report':
                    aspects = review.get('aspect_sentiment', {})
                    for aspect in aspects:
                        issue_counts[aspect] = issue_counts.get(aspect, 0) + 1
            
            if review.get('review_type') == 'feature_request':
                tags = review.get('feature_request_tags', [])
                for tag in tags:
                    feature_counts[tag] = feature_counts.get(tag, 0) + 1
        
        # Create quick wins table
        quick_wins = []
        
        # Top 3 issues
        sorted_issues = sorted(issue_counts.items(), key=lambda x: x[1], reverse=True)[:3]
        for aspect, count in sorted_issues:
            if count >= 3:
                quick_wins.append([
                    "ðŸ”§",
                    f"Fix {aspect} issues",
                    f"{count} mentions",
                    "High"
                ])
        
        # Top 3 feature requests
        sorted_features = sorted(feature_counts.items(), key=lambda x: x[1], reverse=True)[:3]
        for feature, count in sorted_features:
            if count >= 2:
                quick_wins.append([
                    "ðŸ’¡",
                    f"Add {feature}",
                    f"{count} requests",
                    "Medium"
                ])
        
        if quick_wins:
            quick_wins_table = Table(
                [["", "Action", "Evidence", "Priority"]] + quick_wins,
                colWidths=[0.5*inch, 3*inch, 1.5*inch, 1*inch]
            )
            quick_wins_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#f39c12')),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 10),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 10),
                ('BACKGROUND', (0, 1), (-1, -1), colors.HexColor('#fef5e7')),
                ('ALIGN', (1, 1), (1, -1), 'LEFT'),
                ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#f39c12')),
                ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 1), (-1, -1), 9),
                ('TOPPADDING', (0, 1), (-1, -1), 6),
                ('BOTTOMPADDING', (0, 1), (-1, -1), 6),
            ]))
            
            elements.append(quick_wins_table)
        else:
            elements.append(Paragraph("No quick wins identified - monitor feedback for opportunities", self.styles['Normal']))
        
        return elements
    
    def _create_sentiment_section(self, sentiment_data: Dict) -> List:
        """Create sentiment analysis section with charts."""
        elements = []
        
        elements.append(Paragraph(self.t("sentiment_analysis"), self.styles['SectionHeader']))
        elements.append(Spacer(1, 0.2*inch))
        
        # Create sentiment pie chart
        img_path = self._create_sentiment_pie_chart(sentiment_data)
        if img_path:
            img = Image(str(img_path), width=5*inch, height=3.5*inch)
            elements.append(img)
        
        elements.append(Spacer(1, 0.2*inch))
        
        # Create sentiment timeline
        img_path = self._create_sentiment_timeline(sentiment_data)
        if img_path:
            img = Image(str(img_path), width=6*inch, height=3*inch)
            elements.append(img)
        
        return elements
    
    def _create_aspect_section(self, sentiment_data: Dict) -> List:
        """Create aspect sentiment section with heatmap and radar."""
        elements = []
        
        elements.append(Paragraph(self.t("aspect_sentiment"), self.styles['SectionHeader']))
        elements.append(Spacer(1, 0.2*inch))
        
        # Create aspect radar chart
        img_path = self._create_aspect_radar_chart(sentiment_data)
        if img_path:
            img = Image(str(img_path), width=5*inch, height=5*inch)
            elements.append(img)
            elements.append(Spacer(1, 0.3*inch))
        
        # Create aspect heatmap
        img_path = self._create_aspect_heatmap(sentiment_data)
        if img_path:
            img = Image(str(img_path), width=6*inch, height=4*inch)
            elements.append(img)
        
        return elements
    
    def _create_review_section(self, summary: Dict, sentiment_data: Dict) -> List:
        """Create review analysis section."""
        elements = []
        
        elements.append(Paragraph(self.t("review_analysis"), self.styles['SectionHeader']))
        elements.append(Spacer(1, 0.2*inch))
        
        # Review types details table
        review_types = summary.get('review_types', {})
        if review_types:
            elements.append(Paragraph(self.t("review_types"), self.styles['SubSection']))
            
            # Sort by count
            sorted_types = sorted(review_types.items(), key=lambda x: x[1], reverse=True)
            
            # Create table data
            table_data = [['Review Type', 'Count', 'Percentage']]
            total_reviews = sum(review_types.values())
            
            for review_type, count in sorted_types:
                percentage = (count / total_reviews * 100) if total_reviews > 0 else 0
                type_name = review_type.replace('_', ' ').title()
                table_data.append([type_name, str(count), f"{percentage:.1f}%"])
            
            # Add total row
            table_data.append(['Total', str(total_reviews), '100.0%'])
            
            review_table = Table(table_data, colWidths=[2.5*inch, 1*inch, 1.2*inch])
            review_table.setStyle(TableStyle([
                # Header row
                ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#3498db')),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, 0), 'CENTER'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 11),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 10),
                # Data rows
                ('BACKGROUND', (0, 1), (-1, -2), colors.beige),
                ('ALIGN', (0, 1), (0, -1), 'LEFT'),
                ('ALIGN', (1, 1), (-1, -1), 'CENTER'),
                ('FONTNAME', (0, 1), (-1, -2), 'Helvetica'),
                ('FONTSIZE', (0, 1), (-1, -2), 10),
                ('TOPPADDING', (0, 1), (-1, -2), 6),
                ('BOTTOMPADDING', (0, 1), (-1, -2), 6),
                # Total row
                ('BACKGROUND', (0, -1), (-1, -1), colors.HexColor('#ecf0f1')),
                ('FONTNAME', (0, -1), (-1, -1), 'Helvetica-Bold'),
                ('FONTSIZE', (0, -1), (-1, -1), 10),
                ('TOPPADDING', (0, -1), (-1, -1), 8),
                ('BOTTOMPADDING', (0, -1), (-1, -1), 8),
                # Grid
                ('GRID', (0, 0), (-1, -1), 1, colors.black),
            ]))
            
            elements.append(review_table)
            elements.append(Spacer(1, 0.3*inch))
        
        # Review types chart
        img_path = self._create_review_types_chart(summary)
        if img_path:
            img = Image(str(img_path), width=5*inch, height=3.5*inch)
            elements.append(img)
        
        elements.append(Spacer(1, 0.2*inch))
        
        # Rating distribution
        img_path = self._create_rating_distribution(sentiment_data)
        if img_path:
            img = Image(str(img_path), width=5*inch, height=3*inch)
            elements.append(img)
        
        return elements
    
    def _create_keyword_section(self, keyword_data: Dict) -> List:
        """Create keyword insights section with word clouds and tables."""
        elements = []
        
        elements.append(Paragraph(self.t("keyword_insights"), self.styles['SectionHeader']))
        elements.append(Spacer(1, 0.2*inch))
        
        # Description keywords - Keep together
        desc_section = []
        desc_section.append(Paragraph(self.t("description_keywords"), self.styles['SubSection']))
        
        desc_keywords = keyword_data.get('analysis', {}).get('description', {}).get('top_keywords', {})
        
        # Word cloud
        img_path = self._create_wordcloud(desc_keywords)
        if img_path:
            img = Image(str(img_path), width=6*inch, height=2.5*inch)
            desc_section.append(img)
            desc_section.append(Spacer(1, 0.15*inch))
        
        # Top 10 keywords table
        if desc_keywords:
            top_10_desc = sorted(desc_keywords.items(), key=lambda x: x[1], reverse=True)[:10]
            
            # Create table data
            table_data = [['Rank', 'Keyword', 'Frequency']]
            for idx, (keyword, freq) in enumerate(top_10_desc, 1):
                table_data.append([str(idx), keyword, str(freq)])
            
            keyword_table = Table(table_data, colWidths=[0.6*inch, 2.5*inch, 1*inch])
            keyword_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#2c3e50')),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 10),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 8),
                ('BACKGROUND', (0, 1), (-1, -1), colors.HexColor('#ecf0f1')),
                ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
                ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 1), (-1, -1), 9),
                ('TOPPADDING', (0, 1), (-1, -1), 5),
                ('BOTTOMPADDING', (0, 1), (-1, -1), 5),
            ]))
            
            desc_section.append(keyword_table)
        
        # Add description section as KeepTogether
        elements.append(KeepTogether(desc_section))
        
        # Page break before review keywords
        elements.append(PageBreak())
        
        # Review keywords - Keep together
        review_section = []
        review_section.append(Paragraph(self.t("review_keywords"), self.styles['SubSection']))
        
        review_keywords = keyword_data.get('analysis', {}).get('reviews', {}).get('top_keywords', {})
        
        # Word cloud
        img_path = self._create_wordcloud(review_keywords)
        if img_path:
            img = Image(str(img_path), width=6*inch, height=2.5*inch)
            review_section.append(img)
            review_section.append(Spacer(1, 0.15*inch))
        
        # Top 10 keywords table
        if review_keywords:
            top_10_review = sorted(review_keywords.items(), key=lambda x: x[1], reverse=True)[:10]
            
            # Create table data
            table_data = [['Rank', 'Keyword', 'Frequency']]
            for idx, (keyword, freq) in enumerate(top_10_review, 1):
                table_data.append([str(idx), keyword, str(freq)])
            
            keyword_table = Table(table_data, colWidths=[0.6*inch, 2.5*inch, 1*inch])
            keyword_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#2c3e50')),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 10),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 8),
                ('BACKGROUND', (0, 1), (-1, -1), colors.HexColor('#ecf0f1')),
                ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
                ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 1), (-1, -1), 9),
                ('TOPPADDING', (0, 1), (-1, -1), 5),
                ('BOTTOMPADDING', (0, 1), (-1, -1), 5),
            ]))
            
            review_section.append(keyword_table)
        
        # Add review section as KeepTogether
        elements.append(KeepTogether(review_section))
        
        return elements
    
    def _create_insights_section(self, sentiment_data: Dict, keyword_data: Dict) -> List:
        """Create actionable insights section with improved visuals."""
        elements = []
        
        elements.append(Paragraph(self.t("actionable_insights"), self.styles['SectionHeader']))
        elements.append(Spacer(1, 0.2*inch))
        
        # Analyze reviews for insights
        reviews = sentiment_data.get('reviews', [])
        
        # Count negative aspects
        aspect_issues = {}
        feature_requests = {}
        
        for review in reviews:
            if review.get('sentiment_label') == 'negative':
                aspects = review.get('aspect_sentiment', {})
                for aspect, data in aspects.items():
                    if data.get('label') == 'negative':
                        aspect_issues[aspect] = aspect_issues.get(aspect, 0) + 1
            
            if review.get('review_type') == 'feature_request':
                for tag in review.get('feature_request_tags', []):
                    feature_requests[tag] = feature_requests.get(tag, 0) + 1
        
        # Urgent actions with color boxes
        elements.append(Paragraph(f"âš ï¸ {self.t('urgent_actions')}", self.styles['SubSection']))
        
        if aspect_issues:
            sorted_issues = sorted(aspect_issues.items(), key=lambda x: x[1], reverse=True)[:5]
            
            issue_data = []
            for aspect, count in sorted_issues:
                issue_data.append([
                    "âŒ",
                    f"Address {aspect} issues",
                    f"{count} mentions"
                ])
            
            issue_table = Table(issue_data, colWidths=[0.5*inch, 4*inch, 1.5*inch])
            issue_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, -1), colors.HexColor('#fadbd8')),
                ('TEXTCOLOR', (0, 0), (-1, -1), colors.HexColor('#2c3e50')),
                ('ALIGN', (0, 0), (0, -1), 'CENTER'),
                ('ALIGN', (1, 0), (1, -1), 'LEFT'),
                ('ALIGN', (2, 0), (2, -1), 'CENTER'),
                ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 0), (-1, -1), 10),
                ('GRID', (0, 0), (-1, -1), 0.5, colors.HexColor('#e74c3c')),
                ('TOPPADDING', (0, 0), (-1, -1), 8),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
                ('LEFTPADDING', (0, 0), (-1, -1), 10),
            ]))
            
            elements.append(issue_table)
        else:
            elements.append(Paragraph("âœ… No critical issues identified", self.styles['Normal']))
        
        elements.append(Spacer(1, 0.3*inch))
        
        # Feature requests with color boxes
        elements.append(Paragraph(f"ðŸ’¡ {self.t('feature_requests')}", self.styles['SubSection']))
        
        if feature_requests:
            sorted_requests = sorted(feature_requests.items(), key=lambda x: x[1], reverse=True)[:5]
            
            feature_data = []
            for feature, count in sorted_requests:
                feature_data.append([
                    "âœ…",
                    feature,
                    f"{count} requests"
                ])
            
            feature_table = Table(feature_data, colWidths=[0.5*inch, 4*inch, 1.5*inch])
            feature_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, -1), colors.HexColor('#d5f4e6')),
                ('TEXTCOLOR', (0, 0), (-1, -1), colors.HexColor('#2c3e50')),
                ('ALIGN', (0, 0), (0, -1), 'CENTER'),
                ('ALIGN', (1, 0), (1, -1), 'LEFT'),
                ('ALIGN', (2, 0), (2, -1), 'CENTER'),
                ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 0), (-1, -1), 10),
                ('GRID', (0, 0), (-1, -1), 0.5, colors.HexColor('#27ae60')),
                ('TOPPADDING', (0, 0), (-1, -1), 8),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
                ('LEFTPADDING', (0, 0), (-1, -1), 10),
            ]))
            
            elements.append(feature_table)
        else:
            elements.append(Paragraph("No feature requests identified", self.styles['Normal']))
        
        return elements

    
    # Chart generation methods
    
    def _create_sentiment_pie_chart(self, sentiment_data: Dict) -> Optional[Path]:
        """Create sentiment distribution pie chart."""
        try:
            reviews = sentiment_data.get('reviews', [])
            if not reviews:
                return None
            
            # Count sentiments
            sentiments = [r.get('sentiment_label', 'neutral') for r in reviews]
            sentiment_counts = {
                'positive': sentiments.count('positive'),
                'negative': sentiments.count('negative'),
                'neutral': sentiments.count('neutral')
            }
            
            # Filter out zero values
            sentiment_counts = {k: v for k, v in sentiment_counts.items() if v > 0}
            
            if not sentiment_counts:
                return None
            
            # Create pie chart
            fig, ax = plt.subplots(figsize=(8, 6))
            
            colors_map = {
                'positive': '#2ecc71',
                'negative': '#e74c3c',
                'neutral': '#95a5a6'
            }
            
            labels = [self.t(k) for k in sentiment_counts.keys()]
            sizes = list(sentiment_counts.values())
            colors_list = [colors_map[k] for k in sentiment_counts.keys()]
            
            wedges, texts, autotexts = ax.pie(
                sizes,
                labels=labels,
                colors=colors_list,
                autopct='%1.1f%%',
                startangle=90,
                textprops={'fontsize': 12}
            )
            
            # Make percentage text bold
            for autotext in autotexts:
                autotext.set_color('white')
                autotext.set_fontweight('bold')
                autotext.set_fontsize(11)
            
            ax.set_title(self.t("sentiment_breakdown"), fontsize=14, fontweight='bold', pad=20)
            
            # Save to temp file
            temp_path = Path(f"temp_sentiment_pie_{datetime.now().timestamp()}.png")
            plt.tight_layout()
            plt.savefig(temp_path, dpi=150, bbox_inches='tight')
            plt.close()
            
            # Track for cleanup
            self.temp_files.append(temp_path)
            
            return temp_path
            
        except Exception as e:
            print(f"Error creating sentiment pie chart: {e}")
            return None
    
    def _create_sentiment_timeline(self, sentiment_data: Dict) -> Optional[Path]:
        """Create sentiment over time line chart."""
        try:
            reviews = sentiment_data.get('reviews', [])
            if not reviews:
                return None
            
            # Parse dates and sentiments
            data = []
            for review in reviews:
                date_str = review.get('date')
                sentiment_score = review.get('sentiment_score', 0)
                
                if date_str:
                    try:
                        # Handle different date formats
                        if 'T' in str(date_str):
                            date = pd.to_datetime(date_str)
                        else:
                            date = pd.to_datetime(date_str)
                        data.append({'date': date, 'sentiment': sentiment_score})
                    except:
                        continue
            
            if len(data) < 2:
                return None
            
            df = pd.DataFrame(data)
            df = df.sort_values('date')
            
            # Create line chart
            fig, ax = plt.subplots(figsize=(10, 5))
            
            ax.plot(df['date'], df['sentiment'], marker='o', linewidth=2, markersize=4, color='#3498db')
            ax.axhline(y=0, color='gray', linestyle='--', linewidth=1, alpha=0.5)
            
            ax.set_xlabel('Date', fontsize=11, fontweight='bold')
            ax.set_ylabel('Sentiment Score', fontsize=11, fontweight='bold')
            ax.set_title('Sentiment Over Time', fontsize=14, fontweight='bold', pad=15)
            ax.grid(True, alpha=0.3)
            
            plt.xticks(rotation=45, ha='right')
            
            # Save to temp file
            temp_path = Path(f"temp_sentiment_timeline_{datetime.now().timestamp()}.png")
            plt.tight_layout()
            plt.savefig(temp_path, dpi=150, bbox_inches='tight')
            plt.close()
            
            # Track for cleanup
            self.temp_files.append(temp_path)
            
            return temp_path
            
        except Exception as e:
            print(f"Error creating sentiment timeline: {e}")
            return None
    
    def _create_aspect_heatmap(self, sentiment_data: Dict) -> Optional[Path]:
        """Create aspect sentiment heatmap."""
        try:
            reviews = sentiment_data.get('reviews', [])
            if not reviews:
                return None
            
            # Collect aspect sentiments
            aspect_data = {}
            
            for review in reviews:
                aspects = review.get('aspect_sentiment', {})
                for aspect, data in aspects.items():
                    if aspect not in aspect_data:
                        aspect_data[aspect] = {'positive': 0, 'negative': 0}
                    
                    label = data.get('label', '').lower()
                    if label in aspect_data[aspect]:
                        aspect_data[aspect][label] += 1
            
            if not aspect_data:
                return None
            
            # Convert to percentages (only positive/negative)
            aspect_percentages = {}
            for aspect, counts in aspect_data.items():
                total = counts['positive'] + counts['negative']
                if total > 0:
                    aspect_percentages[aspect] = {
                        'positive': counts['positive'] / total * 100,
                        'negative': counts['negative'] / total * 100,
                    }
            
            if not aspect_percentages:
                return None
            
            # Create DataFrame
            df = pd.DataFrame(aspect_percentages).T
            for col in ('positive', 'negative'):
                if col not in df.columns:
                    df[col] = 0
            df = df[['positive', 'negative']]
            
            # Create heatmap
            fig, ax = plt.subplots(figsize=(10, 6))
            
            sns.heatmap(
                df,
                annot=True,
                fmt='.1f',
                cmap='RdYlGn',
                center=50,
                cbar_kws={'label': 'Percentage (%)'},
                linewidths=0.5,
                ax=ax
            )
            
            ax.set_title(self.t("aspect_sentiment"), fontsize=14, fontweight='bold', pad=15)
            ax.set_xlabel('')
            ax.set_ylabel('Aspect', fontsize=11, fontweight='bold')
            
            # Capitalize column names
            ax.set_xticklabels([self.t(col) for col in df.columns], rotation=0)
            
            # Save to temp file
            temp_path = Path(f"temp_aspect_heatmap_{datetime.now().timestamp()}.png")
            plt.tight_layout()
            plt.savefig(temp_path, dpi=150, bbox_inches='tight')
            plt.close()
            
            # Track for cleanup
            self.temp_files.append(temp_path)
            
            return temp_path
            
        except Exception as e:
            print(f"Error creating aspect heatmap: {e}")
            return None
    
    def _create_review_types_chart(self, summary: Dict) -> Optional[Path]:
        """Create review types bar chart."""
        try:
            review_types = summary.get('review_types', {})
            if not review_types:
                return None
            
            # Sort by count
            sorted_types = sorted(review_types.items(), key=lambda x: x[1], reverse=True)
            types = [t[0].replace('_', ' ').title() for t in sorted_types]
            counts = [t[1] for t in sorted_types]
            
            # Create bar chart
            fig, ax = plt.subplots(figsize=(8, 5))
            
            bars = ax.barh(types, counts, color='#3498db')
            
            # Add value labels
            for i, (bar, count) in enumerate(zip(bars, counts)):
                ax.text(count + max(counts)*0.01, i, str(count), 
                       va='center', fontsize=10, fontweight='bold')
            
            ax.set_xlabel('Count', fontsize=11, fontweight='bold')
            ax.set_title(self.t("review_types"), fontsize=14, fontweight='bold', pad=15)
            ax.grid(axis='x', alpha=0.3)
            
            # Save to temp file
            temp_path = Path(f"temp_review_types_{datetime.now().timestamp()}.png")
            plt.tight_layout()
            plt.savefig(temp_path, dpi=150, bbox_inches='tight')
            plt.close()
            
            # Track for cleanup
            self.temp_files.append(temp_path)
            
            return temp_path
            
        except Exception as e:
            print(f"Error creating review types chart: {e}")
            return None
    
    def _create_rating_distribution(self, sentiment_data: Dict) -> Optional[Path]:
        """Create rating distribution histogram."""
        try:
            reviews = sentiment_data.get('reviews', [])
            if not reviews:
                return None
            
            ratings = [r.get('rating', 0) for r in reviews if r.get('rating')]
            if not ratings:
                return None
            
            # Create histogram
            fig, ax = plt.subplots(figsize=(8, 5))
            
            bins = [0.5, 1.5, 2.5, 3.5, 4.5, 5.5]
            ax.hist(ratings, bins=bins, color='#f39c12', edgecolor='black', alpha=0.7)
            
            ax.set_xlabel('Rating', fontsize=11, fontweight='bold')
            ax.set_ylabel('Count', fontsize=11, fontweight='bold')
            ax.set_title('Rating Distribution', fontsize=14, fontweight='bold', pad=15)
            ax.set_xticks([1, 2, 3, 4, 5])
            ax.grid(axis='y', alpha=0.3)
            
            # Save to temp file
            temp_path = Path(f"temp_rating_dist_{datetime.now().timestamp()}.png")
            plt.tight_layout()
            plt.savefig(temp_path, dpi=150, bbox_inches='tight')
            plt.close()
            
            # Track for cleanup
            self.temp_files.append(temp_path)
            
            return temp_path
            
        except Exception as e:
            print(f"Error creating rating distribution: {e}")
            return None
    
    def _create_rating_breakdown_chart(self, sentiment_data: Dict) -> Optional[Path]:
        """Create horizontal bar chart for rating breakdown with stars."""
        try:
            reviews = sentiment_data.get('reviews', [])
            if not reviews:
                return None
            
            # Count ratings
            rating_counts = {1: 0, 2: 0, 3: 0, 4: 0, 5: 0}
            for review in reviews:
                rating = review.get('rating', 0)
                if rating in rating_counts:
                    rating_counts[rating] += 1
            
            total = sum(rating_counts.values())
            if total == 0:
                return None
            
            # Create horizontal bar chart
            fig, ax = plt.subplots(figsize=(10, 6))
            
            ratings = list(rating_counts.keys())
            ratings.sort(reverse=True)  # 5 to 1 (descending)
            counts = [rating_counts[r] for r in ratings]
            percentages = [(c / total * 100) for c in counts]
            
            # Colors from green (5 stars) to red (1 star)
            colors_list = ['#27ae60', '#7dcea0', '#f39c12', '#e67e22', '#e74c3c']
            
            # Use text labels instead of emoji
            rating_labels = [f"{r} Star{'s' if r > 1 else ''}" for r in ratings]
            
            bars = ax.barh(
                rating_labels,
                percentages,
                color=colors_list,
                height=0.6,
                edgecolor='white',
                linewidth=2
            )
            
            # Add percentage labels
            for i, (bar, pct, count) in enumerate(zip(bars, percentages, counts)):
                ax.text(pct + 1, i, f"{pct:.1f}% ({count})", 
                       va='center', fontsize=11, fontweight='bold')
            
            ax.set_xlabel('Percentage (%)', fontsize=12, fontweight='bold')
            ax.set_ylabel('Rating', fontsize=12, fontweight='bold')
            ax.set_title('Rating Distribution', fontsize=14, fontweight='bold', pad=15)
            ax.set_xlim(0, max(percentages) * 1.15)
            ax.grid(axis='x', alpha=0.3, linestyle='--')
            
            # Invert y-axis so 5 Stars appears at the top
            ax.invert_yaxis()
            
            # Save to temp file
            temp_path = Path(f"temp_rating_breakdown_{datetime.now().timestamp()}.png")
            plt.tight_layout()
            plt.savefig(temp_path, dpi=150, bbox_inches='tight')
            plt.close()
            
            # Track for cleanup
            self.temp_files.append(temp_path)
            
            return temp_path
            
        except Exception as e:
            print(f"Error creating rating breakdown chart: {e}")
            return None
    
    def _create_aspect_radar_chart(self, sentiment_data: Dict) -> Optional[Path]:
        """Create radar chart showing aspect performance."""
        try:
            reviews = sentiment_data.get('reviews', [])
            if not reviews:
                return None
            
            # Collect aspect scores (convert sentiment to 0-100 scale)
            aspect_scores = {}
            aspect_counts = {}
            
            for review in reviews:
                aspects = review.get('aspect_sentiment', {})
                for aspect, data in aspects.items():
                    score = data.get('score', 0)
                    if aspect not in aspect_scores:
                        aspect_scores[aspect] = 0
                        aspect_counts[aspect] = 0
                    # Convert -1 to 1 scale to 0 to 100
                    aspect_scores[aspect] += (score + 1) * 50
                    aspect_counts[aspect] += 1
            
            if not aspect_scores:
                return None
            
            # Calculate averages
            aspects = []
            scores = []
            for aspect, total_score in aspect_scores.items():
                count = aspect_counts[aspect]
                if count > 0:
                    aspects.append(aspect.title())
                    scores.append(total_score / count)
            
            if len(aspects) < 3:
                return None
            
            # Create radar chart
            angles = np.linspace(0, 2 * np.pi, len(aspects), endpoint=False).tolist()
            scores += scores[:1]
            angles += angles[:1]
            
            fig, ax = plt.subplots(figsize=(8, 8), subplot_kw=dict(projection='polar'))
            
            ax.plot(angles, scores, 'o-', linewidth=2, color='#3498db', markersize=8)
            ax.fill(angles, scores, alpha=0.25, color='#3498db')
            
            ax.set_xticks(angles[:-1])
            ax.set_xticklabels(aspects, size=11)
            ax.set_ylim(0, 100)
            ax.set_yticks([20, 40, 60, 80, 100])
            ax.set_yticklabels(['20', '40', '60', '80', '100'], size=9)
            ax.grid(True, linestyle='--', alpha=0.7)
            
            ax.set_title(self.t("aspect_radar"), size=14, fontweight='bold', pad=20)
            
            # Save to temp file
            temp_path = Path(f"temp_aspect_radar_{datetime.now().timestamp()}.png")
            plt.tight_layout()
            plt.savefig(temp_path, dpi=150, bbox_inches='tight', facecolor='white')
            plt.close()
            
            # Track for cleanup
            self.temp_files.append(temp_path)
            
            return temp_path
            
        except Exception as e:
            print(f"Error creating aspect radar chart: {e}")
            return None
    
    def _create_wordcloud(self, keywords: Dict[str, int]) -> Optional[Path]:
        """Create improved word cloud from keywords."""
        try:
            if not keywords:
                return None
            
            # Limit to top 30 keywords for better visibility
            top_keywords = dict(sorted(keywords.items(), key=lambda x: x[1], reverse=True)[:30])
            
            # Define custom color function for vibrant colors
            def color_func(*args, **kwargs):
                colors_list = [
                    '#2c3e50',  # Dark blue-grey
                    '#3498db',  # Bright blue
                    '#e74c3c',  # Red
                    '#f39c12',  # Orange
                    '#27ae60',  # Green
                    '#9b59b6',  # Purple
                    '#1abc9c',  # Turquoise
                    '#e67e22',  # Dark orange
                ]
                return np.random.choice(colors_list)
            
            # Create word cloud with better settings
            wordcloud = WordCloud(
                width=1200,
                height=500,
                background_color='white',
                relative_scaling=0.5,
                min_font_size=14,
                max_font_size=100,
                prefer_horizontal=0.7,
                margin=15,
                collocations=False,
                font_path=None,
                color_func=color_func
            ).generate_from_frequencies(top_keywords)
            
            # Create figure
            fig, ax = plt.subplots(figsize=(12, 5))
            ax.imshow(wordcloud, interpolation='bilinear')
            ax.axis('off')
            
            # Save to temp file
            temp_path = Path(f"temp_wordcloud_{datetime.now().timestamp()}.png")
            plt.tight_layout(pad=0)
            plt.savefig(temp_path, dpi=150, bbox_inches='tight', facecolor='#f8f9fa')
            plt.close()
            
            # Track for cleanup
            self.temp_files.append(temp_path)
            
            return temp_path
            
        except Exception as e:
            print(f"Error creating word cloud: {e}")
            return None

    def generate_multi_app_analysis_report(
        self,
        apps: List[Dict[str, Any]],
        output_path: Path,
        title: str = "Screen ASO Batch Report",
    ) -> None:
        """Generate a concise PDF summarizing multiple app analyses."""
        doc = SimpleDocTemplate(
            str(output_path),
            pagesize=self.page_size,
            rightMargin=0.75 * inch,
            leftMargin=0.75 * inch,
            topMargin=0.75 * inch,
            bottomMargin=0.75 * inch,
        )

        story: List[Any] = []
        story.append(Paragraph(title, self.styles["CustomTitle"]))
        story.append(Spacer(1, 0.3 * inch))
        story.append(
            Paragraph(
                f"Total Apps Analyzed: {len(apps)}",
                self.styles["SubSection"],
            )
        )
        story.append(Spacer(1, 0.2 * inch))

        table_data = [
            ["App Name", "Reviews", "Avg Rating", "Positive", "Negative"]
        ]

        for app in apps:
            if not isinstance(app, dict):
                continue

            sentiment = (
                (app.get("review_analysis") or {}).get("sentiment")
                or app.get("sentiment")
                or {}
            )
            reviews_count = (
                (app.get("review_analysis") or {}).get("total_reviews")
                or app.get("total_reviews")
                or app.get("reviews_found")
                or (app.get("review_stats") or {}).get("total_analyzed")
                or len(app.get("reviews", []))
            )
            avg_rating = (
                (app.get("ratings") or {}).get("average")
                or app.get("rating")
                or app.get("rating_value")
                or (app.get("app_info") or {}).get("rating")
                or app.get("user_rating")
            )

            table_data.append(
                [
                    (app.get("app_name") or app.get("name") or "Unknown")[:40],
                    str(reviews_count) if reviews_count not in (None, "") else "-",
                    (
                        f"{float(avg_rating):.2f}"
                        if isinstance(avg_rating, (int, float))
                        else "-"
                    ),
                    str(sentiment.get("positive", "-")),
                    str(sentiment.get("negative", "-")),
                ]
            )

        summary_table = Table(
            table_data,
            colWidths=[2.5 * inch, 1.0 * inch, 1.0 * inch, 1.0 * inch, 1.0 * inch],
        )
        summary_table.setStyle(
            TableStyle(
                [
                    ("BACKGROUND", (0, 0), (-1, 0), colors.HexColor("#2c3e50")),
                    ("TEXTCOLOR", (0, 0), (-1, 0), colors.whitesmoke),
                    ("ALIGN", (0, 0), (-1, -1), "CENTER"),
                    ("FONTNAME", (0, 0), (-1, 0), "Helvetica-Bold"),
                    ("FONTSIZE", (0, 0), (-1, 0), 11),
                    ("BOTTOMPADDING", (0, 0), (-1, 0), 12),
                    ("BACKGROUND", (0, 1), (-1, -1), colors.HexColor("#ecf0f1")),
                    ("GRID", (0, 0), (-1, -1), 0.5, colors.grey),
                    ("FONTNAME", (0, 1), (-1, -1), "Helvetica"),
                    ("FONTSIZE", (0, 1), (-1, -1), 9),
                    ("TOPPADDING", (0, 1), (-1, -1), 6),
                    ("BOTTOMPADDING", (0, 1), (-1, -1), 6),
                ]
            )
        )
        story.append(summary_table)

        doc.build(story)
        self._cleanup_temp_files()
    
    def generate_batch_comparison(
        self,
        batch_summary: Dict,
        app_dirs: List[Path],
        output_path: Path
    ):
        """Generate batch comparison report."""
        
        # Create PDF document
        doc = SimpleDocTemplate(
            str(output_path),
            pagesize=self.page_size,
            rightMargin=0.75*inch,
            leftMargin=0.75*inch,
            topMargin=0.75*inch,
            bottomMargin=0.75*inch
        )
        
        story = []
        
        # Title
        story.append(Paragraph("Batch Comparison Report", self.styles['CustomTitle']))
        story.append(Spacer(1, 0.5*inch))
        
        # Summary
        apps = batch_summary.get('apps', [])
        story.append(Paragraph(f"Total Apps Analyzed: {len(apps)}", self.styles['SubSection']))
        story.append(Spacer(1, 0.3*inch))
        
        # Comparison table
        if apps:
            table_data = [['App Name', 'Rating', 'Reviews', 'Avg Sentiment']]
            
            for app_dir in app_dirs:
                try:
                    with open(app_dir / "summary.json", "r", encoding="utf-8") as f:
                        summary = json.load(f)
                    
                    with open(app_dir / "sentiment_analysis.json", "r", encoding="utf-8") as f:
                        sentiment_data = json.load(f)
                    
                    # Calculate average sentiment
                    reviews = sentiment_data.get('reviews', [])
                    if reviews:
                        avg_sentiment = sum(r.get('sentiment_score', 0) for r in reviews) / len(reviews)
                    else:
                        avg_sentiment = 0
                    
                    table_data.append([
                        summary.get('app_name', 'N/A')[:30],
                        f"{summary.get('rating', 0):.2f}",
                        str(summary.get('reviews_analyzed', 0)),
                        f"{avg_sentiment:.2f}"
                    ])
                except:
                    continue
            
            comparison_table = Table(table_data, colWidths=[3*inch, 1*inch, 1*inch, 1.2*inch])
            comparison_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#3498db')),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 11),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
                ('GRID', (0, 0), (-1, -1), 1, colors.black),
                ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 1), (-1, -1), 9),
                ('TOPPADDING', (0, 1), (-1, -1), 6),
                ('BOTTOMPADDING', (0, 1), (-1, -1), 6),
            ]))
            
            story.append(comparison_table)
        
        # Build PDF
        doc.build(story)
        
        # Cleanup temporary files
        self._cleanup_temp_files()
